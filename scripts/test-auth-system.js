#!/usr/bin/env node

/**
 * Script de test pour le syst√®me d'authentification robuste
 * Usage: node scripts/test-auth-system.js
 */

import dotenv from 'dotenv';
import { createClient } from '@supabase/supabase-js';

// Charger les variables d'environnement
dotenv.config();

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error('‚ùå Variables d\'environnement manquantes !');
  console.error('V√©rifiez que VITE_SUPABASE_URL et VITE_SUPABASE_ANON_KEY sont d√©finies dans .env');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseAnonKey);

// Couleurs pour la console
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

const log = {
  info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
  success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
  warning: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),
  error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
  title: (msg) => console.log(`\n${colors.bright}${colors.cyan}${msg}${colors.reset}`)
};

// Tests √† effectuer
const tests = {
  // Test 1: V√©rifier la connexion √† Supabase
  async testConnection() {
    log.info('Test de connexion √† Supabase...');
    try {
      const { data, error } = await supabase.from('user_profiles').select('count').limit(1);
      if (error) throw error;
      log.success('Connexion √† Supabase r√©ussie');
      return true;
    } catch (error) {
      log.error(`Erreur de connexion: ${error.message}`);
      return false;
    }
  },

  // Test 2: V√©rifier l'existence des tables
  async testTables() {
    log.info('V√©rification des tables...');
    const tables = ['user_profiles', 'user_otps', 'login_attempts', 'trusted_devices'];
    const results = {};

    for (const table of tables) {
      try {
        const { data, error } = await supabase.from(table).select('*').limit(1);
        if (error) throw error;
        results[table] = true;
        log.success(`Table ${table}: OK`);
      } catch (error) {
        results[table] = false;
        log.error(`Table ${table}: ${error.message}`);
      }
    }

    return results;
  },

  // Test 3: V√©rifier les fonctions RPC
  async testRPCFunctions() {
    log.info('V√©rification des fonctions RPC...');
    const functions = [
      'generate_otp',
      'validate_otp',
      'is_user_blocked',
      'record_login_attempt',
      'manage_trusted_device',
      'is_trusted_device',
      'perform_cleanup'
    ];
    const results = {};

    for (const func of functions) {
      try {
        // Test avec des param√®tres factices
        const { data, error } = await supabase.rpc(func, {
          p_email: 'test@example.com',
          p_code: '123456',
          p_code_type: 'login',
          p_user_id: '00000000-0000-0000-0000-000000000000',
          p_device_id: 'test-device',
          p_success: false
        });
        
        // Si on arrive ici, la fonction existe (m√™me si elle peut retourner une erreur logique)
        results[func] = true;
        log.success(`Fonction ${func}: OK`);
      } catch (error) {
        // Si l'erreur indique que la fonction n'existe pas
        if (error.message.includes('function') && error.message.includes('does not exist')) {
          results[func] = false;
          log.error(`Fonction ${func}: Non trouv√©e`);
        } else {
          // La fonction existe mais retourne une erreur logique (normal)
          results[func] = true;
          log.success(`Fonction ${func}: OK (erreur logique attendue)`);
        }
      }
    }

    return results;
  },

  // Test 4: V√©rifier les politiques RLS
  async testRLSPolicies() {
    log.info('V√©rification des politiques RLS...');
    const tables = ['user_profiles', 'user_otps', 'login_attempts', 'trusted_devices'];
    const results = {};

    for (const table of tables) {
      try {
        // Essayer de lire sans authentification (devrait √™tre bloqu√© par RLS)
        const { data, error } = await supabase.from(table).select('*').limit(1);
        
        if (error && error.message.includes('new row violates row-level security policy')) {
          results[table] = true;
          log.success(`RLS actif pour ${table}`);
        } else if (error && error.message.includes('JWT')) {
          results[table] = true;
          log.success(`RLS actif pour ${table} (JWT requis)`);
        } else {
          results[table] = false;
          log.warning(`RLS peut-√™tre d√©sactiv√© pour ${table}`);
        }
      } catch (error) {
        results[table] = false;
        log.error(`Erreur RLS pour ${table}: ${error.message}`);
      }
    }

    return results;
  },

  // Test 5: Test complet du flux d'authentification (simulation)
  async testAuthFlow() {
    log.info('Test du flux d\'authentification...');
    
    try {
      // 1. V√©rifier si un utilisateur de test existe
      const testEmail = 'test-auth@example.com';
      
      // 2. Simuler la g√©n√©ration d'un OTP
      const { data: otpData, error: otpError } = await supabase.rpc('generate_otp', {
        p_email: testEmail,
        p_code_type: 'login',
        p_expires_in_minutes: 5
      });

      if (otpError) {
        if (otpError.message.includes('Utilisateur non trouv√©')) {
          log.warning('Utilisateur de test non trouv√© (normal pour un test)');
          return { success: true, message: 'Test de g√©n√©ration OTP r√©ussi (utilisateur inexistant)' };
        } else {
          throw otpError;
        }
      }

      log.success('G√©n√©ration d\'OTP r√©ussie');
      
      // 3. Simuler la validation d'un OTP
      const { data: validationData, error: validationError } = await supabase.rpc('validate_otp', {
        p_email: testEmail,
        p_code: '123456',
        p_code_type: 'login'
      });

      if (validationError) {
        if (validationError.message.includes('Utilisateur non trouv√©')) {
          log.warning('Validation OTP: utilisateur non trouv√© (normal)');
        } else {
          log.success('Test de validation OTP r√©ussi');
        }
      }

      return { success: true, message: 'Flux d\'authentification test√© avec succ√®s' };
    } catch (error) {
      log.error(`Erreur dans le flux d'authentification: ${error.message}`);
      return { success: false, error: error.message };
    }
  },

  // Test 6: V√©rifier les extensions PostgreSQL
  async testExtensions() {
    log.info('V√©rification des extensions PostgreSQL...');
    const extensions = ['uuid-ossp', 'pgcrypto'];
    const results = {};

    for (const ext of extensions) {
      try {
        const { data, error } = await supabase.rpc('generate_otp', {
          p_email: 'test@example.com',
          p_code_type: 'login',
          p_expires_in_minutes: 5
        });
        
        // Si on arrive ici, les extensions sont probablement install√©es
        results[ext] = true;
        log.success(`Extension ${ext}: OK`);
      } catch (error) {
        if (error.message.includes('function') || error.message.includes('does not exist')) {
          results[ext] = false;
          log.error(`Extension ${ext}: Non disponible`);
        } else {
          results[ext] = true;
          log.success(`Extension ${ext}: OK`);
        }
      }
    }

    return results;
  }
};

// Fonction principale de test
async function runTests() {
  log.title('üß™ TESTS DU SYST√àME D\'AUTHENTIFICATION ROBUSTE');
  log.info('D√©marrage des tests...\n');

  const results = {
    connection: false,
    tables: {},
    rpcFunctions: {},
    rlsPolicies: {},
    authFlow: {},
    extensions: {}
  };

  // Test 1: Connexion
  results.connection = await tests.testConnection();
  if (!results.connection) {
    log.error('Impossible de se connecter √† Supabase. Arr√™t des tests.');
    process.exit(1);
  }

  // Test 2: Tables
  results.tables = await tests.testTables();

  // Test 3: Fonctions RPC
  results.rpcFunctions = await tests.testRPCFunctions();

  // Test 4: Politiques RLS
  results.rlsPolicies = await tests.testRLSPolicies();

  // Test 5: Flux d'authentification
  results.authFlow = await tests.testAuthFlow();

  // Test 6: Extensions
  results.extensions = await tests.testExtensions();

  // R√©sum√© des r√©sultats
  log.title('üìä R√âSUM√â DES TESTS');

  const allTablesOk = Object.values(results.tables).every(Boolean);
  const allFunctionsOk = Object.values(results.rpcFunctions).every(Boolean);
  const allRLSOk = Object.values(results.rlsPolicies).every(Boolean);
  const allExtensionsOk = Object.values(results.extensions).every(Boolean);

  console.log('\n' + '='.repeat(60));
  
  log.info(`Connexion Supabase: ${results.connection ? '‚úÖ' : '‚ùå'}`);
  log.info(`Tables: ${allTablesOk ? '‚úÖ' : '‚ùå'} (${Object.values(results.tables).filter(Boolean).length}/${Object.keys(results.tables).length})`);
  log.info(`Fonctions RPC: ${allFunctionsOk ? '‚úÖ' : '‚ùå'} (${Object.values(results.rpcFunctions).filter(Boolean).length}/${Object.keys(results.rpcFunctions).length})`);
  log.info(`Politiques RLS: ${allRLSOk ? '‚úÖ' : '‚ùå'} (${Object.values(results.rlsPolicies).filter(Boolean).length}/${Object.keys(results.rlsPolicies).length})`);
  log.info(`Extensions: ${allExtensionsOk ? '‚úÖ' : '‚ùå'} (${Object.values(results.extensions).filter(Boolean).length}/${Object.keys(results.extensions).length})`);
  log.info(`Flux d'authentification: ${results.authFlow.success ? '‚úÖ' : '‚ùå'}`);

  console.log('\n' + '='.repeat(60));

  // Recommandations
  log.title('üí° RECOMMANDATIONS');

  if (!allTablesOk) {
    log.warning('Certaines tables sont manquantes. Ex√©cutez le script SQL complet.');
  }

  if (!allFunctionsOk) {
    log.warning('Certaines fonctions RPC sont manquantes. V√©rifiez le script SQL.');
  }

  if (!allRLSOk) {
    log.warning('Certaines politiques RLS ne sont pas actives. V√©rifiez la s√©curit√©.');
  }

  if (!allExtensionsOk) {
    log.warning('Certaines extensions PostgreSQL sont manquantes. V√©rifiez l\'installation.');
  }

  if (results.connection && allTablesOk && allFunctionsOk && allRLSOk && allExtensionsOk) {
    log.success('üéâ Tous les tests sont pass√©s ! Le syst√®me d\'authentification est pr√™t.');
    log.info('Vous pouvez maintenant tester l\'application avec : npm run dev');
  } else {
    log.error('‚ùå Certains tests ont √©chou√©. V√©rifiez la configuration.');
    process.exit(1);
  }

  console.log('\n' + '='.repeat(60));
}

// Ex√©cuter les tests
runTests().catch(error => {
  log.error(`Erreur fatale: ${error.message}`);
  process.exit(1);
});
